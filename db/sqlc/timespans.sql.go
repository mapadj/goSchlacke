// Code generated by sqlc. DO NOT EDIT.
// source: timespans.sql

package db

import (
	"context"
	"database/sql"
)

const countTimespansV1 = `-- name: CountTimespansV1 :one
SELECT 
   COUNT(*) 
FROM 
   timespans
`

func (q *Queries) CountTimespansV1(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTimespansV1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertTimespansV1 = `-- name: UpsertTimespansV1 :one
INSERT INTO timespans (
  schwacke_id,
  schwacke_code,
  valid_from,
  valid_until
) VALUES (
  $1, $2, $3, $4
) 
ON CONFLICT (schwacke_id) 
DO UPDATE SET 
  schwacke_code = EXCLUDED.schwacke_code,
  valid_from = EXCLUDED.valid_from,
  valid_until = EXCLUDED.valid_until
  RETURNING schwacke_id, schwacke_code, valid_from, valid_until
`

type UpsertTimespansV1Params struct {
	SchwackeID   int32         `json:"schwacke_id"`
	SchwackeCode sql.NullInt32 `json:"schwacke_code"`
	ValidFrom    sql.NullTime  `json:"valid_from"`
	ValidUntil   sql.NullTime  `json:"valid_until"`
}

func (q *Queries) UpsertTimespansV1(ctx context.Context, arg UpsertTimespansV1Params) (Timespan, error) {
	row := q.db.QueryRowContext(ctx, upsertTimespansV1,
		arg.SchwackeID,
		arg.SchwackeCode,
		arg.ValidFrom,
		arg.ValidUntil,
	)
	var i Timespan
	err := row.Scan(
		&i.SchwackeID,
		&i.SchwackeCode,
		&i.ValidFrom,
		&i.ValidUntil,
	)
	return i, err
}
