// Code generated by sqlc. DO NOT EDIT.
// source: rims.sql

package db

import (
	"context"
	"database/sql"
)

const countRimsV1 = `-- name: CountRimsV1 :one
SELECT 
   COUNT(*) 
FROM 
   rims
`

func (q *Queries) CountRimsV1(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRimsV1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const upsertRimsV1 = `-- name: UpsertRimsV1 :one
INSERT INTO rims (
  code,
  width,
  height,
  one_piece,
  diameter,
  material
) VALUES (
  $1, $2, $3, $4, $5, $6
) 
ON CONFLICT (code) 
DO UPDATE SET 
  width = EXCLUDED.width,
  height = EXCLUDED.height,
  one_piece = EXCLUDED.one_piece,
  diameter = EXCLUDED.diameter,
  material = EXCLUDED.material
RETURNING code, width, height, one_piece, diameter, material
`

type UpsertRimsV1Params struct {
	Code     int32          `json:"code"`
	Width    sql.NullString `json:"width"`
	Height   sql.NullString `json:"height"`
	OnePiece sql.NullBool   `json:"one_piece"`
	Diameter sql.NullInt32  `json:"diameter"`
	Material sql.NullString `json:"material"`
}

func (q *Queries) UpsertRimsV1(ctx context.Context, arg UpsertRimsV1Params) (Rim, error) {
	row := q.db.QueryRowContext(ctx, upsertRimsV1,
		arg.Code,
		arg.Width,
		arg.Height,
		arg.OnePiece,
		arg.Diameter,
		arg.Material,
	)
	var i Rim
	err := row.Scan(
		&i.Code,
		&i.Width,
		&i.Height,
		&i.OnePiece,
		&i.Diameter,
		&i.Material,
	)
	return i, err
}
